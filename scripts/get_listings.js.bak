/*
 * Pass in valid opts to gen listings
 * (intended for cron)
 */
var request      = require("request")
    , cheerio    = require("cheerio")
    , async      = require("async") 
    , MM         = require('../models/rents.js');

// opts:
var argv = require('optimist')
    .usage('Usage: $0 --type [string] --name [string] --link [string]')
    .demand(['type','name','link'])
    .argv;

// log:
var dt      = new Date();
var fdt     = dt.getFullYear()+'-'+dt.getMonth()+'-'+dt.getDay();
var logpath = '../logs/listings/'+fdt+'_'+argv.name+'.log';
var winston = require("winston");
var log     = new (winston.logger)({
    transports: [
        new (winston.transports.Console)(),
        new (winston.transports.File)({ filename: logpath})
    ]
});

var name_list = ['state_name','area_name','region_name','nbhood_name'];
var nextlvl = new Array();
nextlvl.state = 'area';
nextlvl.area = 'region';
nextlvl.region = 'nbhood';

function ah(type,prev_type,prev_names,name) {
    var typeupper = type.charAt(0).toUpperCase() + type.slice(1); 
    if (prev_type) {
        MM[typeupper].find({prev_type+'_name': name},function(err,objs) {
            if (!objs || objs.length === 0) {
                //error
            }
            var ct = objs.length;
            var cur_names = new Array();
            objs.forEach(function(obj) {
                if (obj.ah_link) {
                    //push to queue
                    var ah_task = {};
                    for (var i=0; i<prev_names.length; i++) {
                       ah_task.place[names_list[i]] = prev_names[i]; 
                    }
                    ah_task.link = obj.ah_link;
                    q.push(ah_task, function(err) {
                        //log here
                    });
                }
                else {
                    if (nextlvl[type]) {
                        prev_names.push(obj.name);
                        ah(nextlvl[type],type,prev_names,obj.name);
                    }
                }
            });
        });
    }
    else {
        MM[typeupper].find({name: name}, function(err,obj) {
            if (obj) {
                ah(nextlvl[type],type,prev_names,names);
            }
        });
    }
}

// ah_link get funcs, per level:
var state_name = '';    // all listings share state per run
var toplvl = false;
var ah_link_gets = [
    function(cb) {
        // state lvl
        toplvl = true;
        MM.State.findOne({name: argv.name},function(err,state) {
            if (!err && state) {
               state_name = argv.name ;
            }
        });
        cb(null,'');
    },
    function(cb) {
        // area lvl
        if (!toplvl) {
            toplvl = true;
            MM.Area.findOne({name: argv.name},function(err,area) {
                if (!err && area) {
                   state_name = area.state_name; 
                }
            });
            cb(null,'');
        }
        else {
            MM.Area.find({state_name: state_name},function(err,areas) {
                if (!areas || areas.length === 0) {
                    //error
                }
                var
                areas.forEach(function(area) {
                    if (area.ah_link) {
                        //push to queue
                    }
                    else {
                        
                    }
                });
            });
        }
    },
    function() {
        // region lvl
    },
    function() {
        // nbhood lvl
    },
];



function get_listings() {
    // do some input checking on the argv stuff here
    // ditch out if not good values
   
    async.waterfall([
        function(callback) {
            var ahs = new Array();
            var mmroot;
            switch(argv.type) {
                case 'state':
                   mmroot = MM.State; 
                   break;
                case 'area':
                   mmroot = MM.Area; 
                   break;
                case 'region':
                   mmroot = MM.Region; 
                   break;
                case 'nbhood':
                   mmroot = MM.NBHood; 
                   break;
                case 'default': // handle above in input checks
                    break;
            }
            mmroot.find({name: argv.name}, function(err, res) {
                if (!res || res.length === 0) {
                    // bad name
                }
                
            });
        },
        function(ahs, callback) {
        }],
        function(err,results) {
        }
    });
}

//get_listings();
